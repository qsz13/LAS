{
    "contents" : "\ngetCommonNode <- function(network.graph, matrix){\n  network.node <- V(network.graph)$name\n  matrix.node <- row.names(matrix) \n  common.node <- intersect(network.node, matrix.node)\n  return(common.node)\n}\n\ncleanGraph <- function(network.graph, remain){\n  network.node <- V(network.graph)$name\n  delete <- setdiff(network.node, remain)\n  network.graph <- delete.vertices(network.graph, delete)\n  return(network.graph)\n}\n\ncleanMatrix <- function(express.matrix, remain)\n{\n  express.matrix <- express.matrix[rownames(b)%in%remain,]\n  return(express.matrix)\n}\n\nlascore = function(x,y,z)\n{\n  sum(x*y*z)/length(x)\n}\n\nlas <- function(network.graph, express.matrix, k=2, width=2, n.cores=4, need.normalize=TRUE){\n  network.node <- V(network.graph)$name\n  matrix.node <- row.names(matrix)\n  if(!identical(intersect(network.node,matrix.node),union(network.node,matrix.node))){\n    common.node <- getCommonNode(network.graph, express.matrix)\n    network.graph <- cleanGraph(network.graph, common.node)\n    express.matrix <- cleanMatrix(express.matrix, common.node)\n  }\n  size <- length(common.node)\n  if(need.normalize)\n  {\n    normalizeMatrix(express.matrix)\n    cat(\"normalized\\n\")\n  }\n  \n  if(k!=1)\n  {\n    graph.connected <- connect.neighborhood(network.graph,k)\n    connected.list <- as.matrix(get.edgelist(graph.connected))\n  }\n  else\n  {\n    connected.list <- as.matrix(get.edgelist(network.graph))\n  }\n  row.size <- nrow(connected.list)\n  #row.size<-5000\n  cl <- makeCluster(n.cores)\n  registerDoParallel(cl)\n  \n\n  express.matrix.t <- t(express.matrix)/75\n  ptm <- proc.time()\n\n  cat(\"loop begin\\n\")\n\n  result <- foreach(i=1:row.size) %dopar%\n  {\n\n    xy <- express.matrix[connected.list[i,1],]*express.matrix[connected.list[i,2],]\n    \n    la.vector <- c(xy%*%express.matrix.t)\n\n    lfdr <- fdrtool(la.vector, verbose=FALSE, plot = FALSE)$lfdr\n\n    return(rownames(express.matrix)[which(lfdr<0.2)])\n\n  }\n  stopCluster(cl)\n  print(proc.time() - ptm)\n  \n  node.z <- Matrix(0, nrow = size, ncol = size,dimnames=list(rownames(express.matrix),rownames(express.matrix)))\n  for(i in 1:row.size)\n  {\n    if(length(result[[i]])!=0 )\n    {\n      x = connected.list[i,1]\n      y = connected.list[i,2]\n      node.z[x,c(result[[i]])] = 1\n      node.z[y,c(result[[i]])] = 1\n    }\n  }\n  \n  #result = findz(node.z, network.graph)\n  return(node.z)\n  \n}\n\n\nfindz <- function(relate.matrix, network.graph ) {\n  weight0 = dnorm(0)\n  weight1 = dnorm(1)\n  weight2 = dnorm(2)\n  \n  size = nrow(relate.matrix)\n  \n  relate.matrix\n  \n  relate.matrix = relate.matrix[order(rownames(relate.matrix)), ] \n  relate.matrix = relate.matrix[,order(colnames(relate.matrix)) ] \n  \n  \n  result <- weight0*relate.matrix\n\n\n  adjacency1 <- get.adjacency(network.graph, type=\"both\")\n\n  adjacency2 <- get.adjacency(connect.neighborhood(network.graph,2), type=\"both\")-adjacency1\n\n  \n  \n  \n  adjacency1 = adjacency1[order(rownames(adjacency1)), ] \n  adjacency1 = adjacency1[,order(colnames(adjacency1)) ] \n  adjacency2 = adjacency2[order(rownames(adjacency2)), ] \n  adjacency2 = adjacency2[,order(colnames(adjacency2)) ] \n  \n  result <- result+relate.matrix%*%(adjacency1*weight1)\n\n  result <- result+relate.matrix%*%(adjacency2*weight2)\n\n  \n  \n  \n  return(result)\n  \n}\n\n\n\n\n\n\n\n\n\n",
    "created" : 1429022583858.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "937583533",
    "id" : "2959F165",
    "lastKnownWriteTime" : 1429290110,
    "path" : "~/Workspace/Bio/LAS/R/las.R",
    "project_path" : "R/las.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}